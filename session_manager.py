import uuid
from fastapi import HTTPException
from huggingface_client import send_to_huggingface_api
from typing import Dict, Any, List, Optional
import logging

# Configure logging
logger = logging.getLogger(__name__)

# In-memory session storage
user_sessions: Dict[str, Dict[str, Any]] = {}

# System prompt for simplifying reports
SYSTEM_PROMPT = """
Consider me as a layman, a general person who doesn't have any knowledge of the medical field.
I have my medical report. What I would like from you is, I will give you the text of my report, 
the report contains many complex medical terms that I can't understand or any normal person cannot understand. 
So I want you to read the report, analyze it, and then give me a report which will be made by you in very simple terms and 
things which can be understood by me or any normal person.

The response from you should always include only abnormalities or answers based on the questions asked by the user. If the findings are all normal, state it briefly.
Format your response using markdown, and conclude with this disclaimer:

*"This report has been generated by artificial intelligence and is intended to provide a simplified explanation of your medical condition. However, it is always advisable to consult a healthcare professional for definitive diagnosis and treatment."*
"""


def generate_session_id() -> str:
    """
    Generates a unique session ID using UUID.

    Returns:
        str: A unique session ID.
    """
    return str(uuid.uuid4())


def simplify_report(report_text: str) -> Dict[str, str]:
    """
    Takes the extracted text from a medical report and generates a simplified version.

    Args:
        report_text (str): The text extracted from the medical report.

    Returns:
        Dict[str, str]: A dictionary containing the session ID and simplified report.

    Raises:
        HTTPException: If there is an error simplifying the report.
    """
    if not report_text:
        logger.error("Empty report text provided.")
        raise HTTPException(status_code=400, detail="Report text cannot be empty.")

    try:
        # Send the report text to the Hugging Face API for simplification
        simplified_report = send_to_huggingface_api([
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": report_text}
        ])

        # Generate a new session ID
        session_id = generate_session_id()

        # Store the report and initialize session history
        user_sessions[session_id] = {
            "medical_report": report_text,
            "history": []  # Stores previous user queries and bot responses
        }

        return {"session_id": session_id, "simplified_report": simplified_report}
    except HTTPException as http_exc:
        logger.error(f"HTTP exception in simplify_report: {http_exc.detail}")
        raise http_exc
    except Exception as e:
        logger.error(f"Unexpected error in simplify_report: {e}")
        raise HTTPException(status_code=500, detail=f"Error simplifying report: {str(e)}")


def handle_user_question(session_id: str, question: str) -> str:
    """
    Handles user queries related to the uploaded medical report.

    Args:
        session_id (str): The session ID associated with the user's report.
        question (str): The user's question about the report.

    Returns:
        str: The response to the user's question.

    Raises:
        HTTPException: If the session is not found or there is an error handling the question.
    """
    if not session_id or not question:
        logger.error("Invalid session ID or question provided.")
        raise HTTPException(status_code=400, detail="Session ID and question cannot be empty.")

    if session_id not in user_sessions:
        logger.error(f"Session not found: {session_id}")
        raise HTTPException(status_code=404, detail="Session not found.")

    # Fetch session data
    session_data = user_sessions[session_id]
    history: List[Dict[str, str]] = session_data["history"]

    # Build the prompt for Hugging Face API
    if not history:
        # First question: Include the medical report and question
        prompt = f"""
Here is the medical report:
{session_data["medical_report"]}

Question: {question}
"""
    else:
        # Subsequent questions: Only include the conversation history
        history_context = "\n".join([f"Q: {h['question']}\nA: {h['answer']}" for h in history])
        prompt = f"""
Conversation so far:
{history_context}

Question: {question}
"""

    try:
        # Get response from Hugging Face API
        response = send_to_huggingface_api([
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": prompt}
        ])

        # Save question and answer in the session history
        session_data["history"].append({
            "question": question,
            "answer": response
        })

        return response
    except HTTPException as http_exc:
        logger.error(f"HTTP exception in handle_user_question: {http_exc.detail}")
        raise http_exc
    except Exception as e:
        logger.error(f"Unexpected error in handle_user_question: {e}")
        raise HTTPException(status_code=500, detail=f"Error handling question: {str(e)}")


def end_session(session_id: str) -> Dict[str, str]:
    """
    Ends a session and removes associated data.

    Args:
        session_id (str): The session ID to end.

    Returns:
        Dict[str, str]: A confirmation message.

    Raises:
        HTTPException: If the session is not found.
    """
    if not session_id:
        logger.error("Invalid session ID provided.")
        raise HTTPException(status_code=400, detail="Session ID cannot be empty.")

    if session_id not in user_sessions:
        logger.error(f"Session not found: {session_id}")
        raise HTTPException(status_code=404, detail="Session not found.")

    # Remove the session data
    del user_sessions[session_id]
    return {"message": "Session ended and data cleared successfully."}